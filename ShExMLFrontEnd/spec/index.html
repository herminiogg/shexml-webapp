<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>Shape Expressions Mapping Language (ShExML)</title>
    <script 
     src='https://www.w3.org/Tools/respec/respec-w3c' 
     class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "unofficial",
        editors: [{
          name: "Herminio García-González",
          url: "https://herminiogarcia.com",
          company: "Kazerne Dossin",
          companyURL: "https://kazernedossin.eu/en/"
        }],
        latestVersion: "https://shexml.herminiogarcia.com/spec",
        edDraftURI: "https://shexml.herminiogarcia.com/spec",
        shortName: "shexml",
        localBiblio: {
            "SHEX": {
                title: "Shape Expressions Language 2.1",
                href: "http://shex.io/shex-semantics/",
                status: "CG-DRAFT"
            },
            "RDFDatasets": {
                title: "RDF 1.1: On Semantics of RDF Datasets",
                href: "https://www.w3.org/TR/rdf11-datasets/",
                status: "W3C Working Group Note"
            },
            "BCP47": {
                title: "Tags for Identifying Languages",
                href: "https://tools.ietf.org/html/bcp47",
                status: "Internet Best Current Practices for the Internet Community"
            },
            "Jsonpath": {
                title: "JSONPath - XPath for JSON",
                href: "https://goessner.net/articles/JsonPath/",
                status: "Specification proposal"
            }
        }
      };
    </script>
    <script defer src="https://cloud.umami.is/script.js" data-website-id="27651670-a3cb-4fe2-a89e-92132f341641"></script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This document describes Shape Expressions Mapping Language (hereinafter referred as ShExML), an heterogeneous data mapping
        language based on Shape Expressions (ShEx). ShExML has the objective to allow users to map and merge their heterogeneous data
        sources into a single RDF representation. As being based on ShEx, the syntax of ShExML is similar to the ShEx one and the gap between
        them is low. The rest of the document describes the syntax of ShExML and how each element can be used.
      </p>
    </section>
    <section id='sotd'>
      <!--<p>
        This is required.
      </p>-->
    </section>
    <section>
        <h2>Introduction</h2>
        <p>
            A ShExML script can be divided in two main blocks: declarations and generators. The declarations part allows the users to define some
            variables that will be used later in other declarations and in generators. The generators, by its side, are the way for defining the
            pattern of the output. 
        </p>
        <p>
            Inside the declarations there are prefixes, sources, iterators, fields and expressions. Prefixes are the way
            for defining the prefixes that will be used in the RDF output, this is the same concept as in Turtle and SPARQL. Sources allow to define
            the files from which the user want to take the information to process. Iterators define in which part of a document there are multiple entities
            and therefore the engine must iterate over them. Fields, by its side, define the queries to get different values of an entity. And expressions define
            how to merge or transform the obtained values.
        </p>
        <p>
            Generators are divided in graphs and shapes (generation of quads and triples respectively).
            A shape is conformed by a shape name (variable to refer to it), the subject expression to generate the different subjects and a set of terminal and object expressions
            to generate the triples for the various entities. For more information about how shapes are conceived please refer to ShEx specification [[SHEX]].
            A graph is conformed by a graph name and various shapes. The graph name will be used to give a name to the generated named graph.
        </p>
    </section>
    <section>
        <h2>ShExML at a glance</h2>
        <p>In this section a simple example is showed for better understanding of the language and the rest of the document.</p>
        <aside class="example" title="Films ShExML script">
            <pre>    
PREFIX : &lt;http://example.com/&gt;
SOURCE films_xml_file &lt;https://rawgit.com/herminiogg/ShExML/master/src/test/resources/films.xml&gt;
SOURCE films_json_file &lt;https://rawgit.com/herminiogg/ShExML/master/src/test/resources/films.json&gt;
ITERATOR film_xml &lt;xpath: //film&gt; {
    FIELD id &lt;@id&gt;
    FIELD name &lt;name&gt;
    FIELD year &lt;year&gt;
    FIELD country &lt;country&gt;
    FIELD directors &lt;directors/director&gt;
}
ITERATOR film_json &lt;jsonpath: $.films[*]&gt; {
    FIELD id &lt;id&gt;
    FIELD name &lt;name&gt;
    FIELD year &lt;year&gt;
    FIELD country &lt;country&gt;
    FIELD directors &lt;director&gt;
}
EXPRESSION films &lt;films_xml_file.film_xml UNION films_json_file.film_json&gt;

:Films :[films.id] {
    :name [films.name] ;
    :year [films.year] ;
    :country [films.country] ;
    :director [films.directors] ;
}
            </pre>
        </aside>
        <p>
            As previously stated, a ShExML script can be divided in two main parts: declarations and generators. 
        </p>
        <p>
            In the declarations part a prefix is defined which is the ':' prefix for the example URI. This prefix will be used later in the shape
            construction. Then, two sources are defined, one for the XML file and the other one for the JSON file. Two iterators are defined
            for each of the sources. Each iterator has a base query and different partial queries that compose each field. Finally, a union between
            two iterators is defined which allows to combine its fields results.
        </p>
        <p>
            In the generators part, a shape is defined to specify the form of the output data. The :Films shape obtains its subjects from the films.ids expression (note that this
            is possible because the union of two iterators has been made; therefore, it is possible to extract the values with the '.' accessor).
            Then, four tuples of predicate and object are defined. Each of these tuples defines a predicate (in the form of prefix + name) and an object which will
            be, normally, an expression. Therefore, triples will be created in the form of subject, predicate and object.
        </p>
    </section>
    <section>
        <h2>Declarations</h2>
        <section>
            <h2>Prefix</h2>
            <p>
                A prefix is the way to declare a variable that will be substituted for the corresponding URI when it is called. This prefixes are normally
                used as a shorter version of the URI and allow to avoid the repetition of long URIs over the document. This is the same notion as in 
                Turtle and SPARQL. In ShExML, they are composed as showed in the following example. 
            </p>
            <aside class="example" title="Prefix example">
                <pre>
PREFIX : &lt;http://example.com/&gt;
PREFIX dbr: &lt;http://dbpedia.org/resource/&gt;
PREFIX schema: &lt;http://schema.org/&gt;
                </pre>
            </aside>
        </section>
        <section>
            <h2>Source</h2>
            <p>
                A source is the declaration that allows to define a data source from a given URL. This URL will be the link to a file in one of the
                supported formats. For databases the JDBC URL will be used instead. A variable is defined to refer to this declaration. The following example shows how to declare three files, one from
                the internet and two other local files (absolute and relative paths). In addition, a database connection is also defined under the database variable.
            </p>
            <aside class="example" title="Source example">
                <pre>
SOURCE xml_file &lt;https://example.com/file.xml&gt;
SOURCE json_file &lt;file:///example/path/to/file/file.json&gt;
SOURCE json_relative_path &lt;file.json&gt;
SOURCE database &lt;jdbc:mysql://localhost:3306/mydb&gt;
                </pre>
            </aside>
            <section>
                <h3>Types of allowed sources</h3>
                <p>
                    ShExML is conceived with the mission to process many different formats. Therefore many formats are allowed and more are planned to be added in the future. Nowadays, the following ones are fully supported:
                    <ul>
                        <li>JSON</li>
                        <li>XML</li>
                        <li>CSV</li>
                        <li>Relational Databases (using JDBC URL)</li>
                        <li>RDF via SPARQL queries</li>
                    </ul>
                </p>
            </section>
            <section>
            <h3>Wilcards</h3>
                <p>In order to allow conversion of multiple files the "*" wildcard is allowed and can be used as shown in the following example. So, example*.xml will match all xml files beginning with the word "example".</p>
                <aside class="example" title="Source wildcard example">
                    <pre>
    SOURCE xml_file &lt;/path/to/example*.xml&gt;
                    </pre>
                </aside>
            </section>
        </section>
        <section>
            <h2>Query</h2>
            <p>
                Query declaration is used whenever a query wants to be separated from the iterator definition (e.g., long queries or multi-line queries).
                The query can be defined inline or it can be externalised in a file. In the case of defining it inline the same syntax as in iterators is used (see first example).
                In the case of external files and URL is expected as within the Source declaration. Here, 
                there is no need to use any iterator keyword as it is inferred from file extension.
            </p>
            <aside class="example" title="Query declaration example">
                <pre>
QUERY inline_query &lt;sql: SELECT * FROM example;&gt;
QUERY external_query &lt;/path/to/example_query.sparql&gt;
                </pre>
            </aside>
        </section>
        <section>
            <h2>Iterator</h2>
            <p>
                An iterator is used whenever there is a data structure that can be repeated along the file. Therefore, a query is defined to specify where
                the iterator must iterate. The iterator accepts XPath, JSONPath and SQL queries which must be identified with the 'xpath:', 'jsonpath:' or 'sql:' keyword
                before its definition. In the example below there is the definition of an Iterator for XPath and for JSONPath. In the following subsections the elements that 
                can be nested inside the iterators are described. The '{' and '}' symbols are used to open and close the block of nested content respectively.
            </p>
            <aside class="example" title="Iterator example">
                <pre>
ITERATOR example &lt;xpath: /path/to/entity&gt; { }
ITERATOR example &lt;jsonpath: $.path.to.entity[*]&gt; { }
                </pre>
            </aside>
            <section>
                <h3>Iterator types</h3>
                <p>The following iterators and their keywords are now available in ShExML. One for each format type available.
                    <ul>
                        <li><strong>xpath:</strong> (XPath query for XML files)</li>
                        <li><strong>jsonpath:</strong> (JSONPath query for JSON files)</li>
                        <li><strong>csvperrow</strong> (CSV iterator row by row)</li>
                        <li><strong>sql:</strong> (SQL query with a table of results, to be iterated row by row)</li>
                        <li><strong>sparql:</strong> (SPARQL query with a table of result, to be iterated row by row)</li>
                        <li>External query: It is possible to define queries in an external clause or file using their variable name (previously defined with QUERY declaration)</li>
                    </ul>
                </p>
            </section>
            <section>
                <h2>Field</h2>
                <p>
                    A field is a partial query defined from the base of an iterator query. Once the result of the iterator query is iterated, the partial query can be applied
                    to obtain the field value or values. It is important to remark that it is possible to return not only one result but more than one. That is, if the result is
                    a list of results, that will be reflected on the output. The partial query can be defined as a normal XPath or JSONPath query but ommiting the first '/' or '.'
                    navigational symbols because they are attached by the engine. In the case of CSV or Relational databases results field are the names of the columns that want to be retrieved. Therefore, an example iterator with fields is presented below.
                    <aside class="example" title="Field example">
                        <pre>
ITERATOR example &lt;xpath: /path/to/entity&gt; {
    FIELD field1 &lt;@attribute&gt;
    FIELD field2 &lt;field2&gt;
    FIELD field3 &lt;path/to/field3&gt;
}
                        </pre>
                    </aside>
                </p>
                <section>
                    <h3>Pushed and popped fields</h3>
                    <p>Pushed and popped fields can be used to push values down into a hierarchical iteration model. For example,
                        with JSONPath [[Jsonpath]] it is not possible to query parent nodes to get their values as it can done with XPath. Therefore,
                        ShExML offers this possibility with PUSHED_FIELD keyword which tells the engine to save this value when going deeper
                        in the hierarchy iteration. Then, this value can be retrieved with POPPED_FIELD keyword using pushed field variable name
                        as the query.
                    </p>
                    <aside class="example" title="Pushed and popped fields example">
                        <pre>
ITERATOR example &lt;jsonpath: $&gt; {
    PUSHED_FIELD field1 &lt;id&gt;
    ITERATOR nestedIterator &lt;nestedElements[*]&gt; {
        POPPED_FIELD field2 &lt;field1&gt;
        FIELD field3 &lt;field3&gt;
    }
}
                        </pre>
                    </aside>
                </section>
            </section>
            <section>
                <h2>Nested Iterator</h2>
                <p>
                    It is also possible to nest iterators inside other iterators. This allows to cover more complicated structures where there are nested entities. Defining a
                    nested iterator is made as a normal iterator, i.e., it has the same syntax of an iterator but nested inside the main one. Then, the engine will iterate over
                    the results of the first iterator. The Field example but expanded for nested iterators is presented below.
                </p>
                <aside class="example" title="Nested Iterator example">
                    <pre>
ITERATOR example &lt;xpath: /path/to/entity&gt; {
    FIELD field1 &lt;@attribute&gt;
    FIELD field2 &lt;field2&gt;
    FIELD field3 &lt;path/to/field3&gt;
    ITERATOR nested &lt;path/to/sub/entity&gt; { }
}
                    </pre>
                </aside>
            </section>
        </section>
        <section>
            <h2>Expression</h2>
            <p>
                Expressions allow to apply queries over different files by the use of the previous defined declarations. Moreover, they also permit to make some 
                operations over the results. These operations can be applied in the iterator level or in the field level.
            </p>
            <section>
                <h2>Basic expression</h2>
                <p>
                    This is the most basic expression that can be defined and it is used when only one source is defined. It is composed of a file variable and the
                    route to the iterators and fields to apply.
                </p>
                <section>
                    <h2>Basic expression over iterators</h2>
                    <p>
                        A basic expression can be used with an iterator without defining the fields that want to be accesed. Therefore, the expression will produce
                        a set of values that can be accesed later in the shapes by the name of the iterators fields. In the example expression a set containing the
                        values of field1 and field2 is produced.
                    </p>
                    <aside class="example" title="Basic expression over iterators example">
                            <pre>
ITERATOR example &lt;xpath: /path/to/entity&gt; {
    FIELD field1 &lt;@attribute&gt;
    FIELD field2 &lt;field2&gt;
}
EXPRESSION exp &lt;file.example&gt;
                            </pre>
                        </aside>
                </section>
                <section>
                        <h2>Basic expression over fields</h2>
                        <p>
                            A basic expression can be used with an iterator field. Therefore, the expression will produce only the value of this query. This kind of
                            expression can be used with further operations to define with higher granularity the output to produce. In the example, only the value of
                            field1 is taken.
                        </p>
                        <aside class="example" title="Basic expression over fields example">
                                <pre>
ITERATOR example &lt;xpath: /path/to/entity&gt; {
    FIELD field1 &lt;@attribute&gt;
    FIELD field2 &lt;field2&gt;
}
EXPRESSION exp &lt;file.example.field1&gt;
                            </pre>
                        </aside>
                    </section>
            </section>
            <section>
                <h2>Union</h2>
                <p>
                    Unions are the way to merge the results of various different basic expressions. With this operation it is possible to combine different sources to
                    produce a new RDF graph.
                </p>
                <section>
                    <h2>Union over iterators</h2>
                    <p>
                        Unions can be used over iterators when the different iterators fields want to be merged. In order to merge, the requirement is that those fields
                        that want to be merged must have the same name. In the example below, the field1 will be the merge of the two iterators fields, but field2 and
                        field3 will only have their respective values.
                    </p>
                    <aside class="example" title="Union over iterators example">
                        <pre>
ITERATOR it1 &lt;xpath: /path/to/entity&gt; {
    FIELD field1 &lt;@attribute1&gt;
    FIELD field2 &lt;field2&gt;
}
ITERATOR it2 &lt;jsonpath: $.path.to.entity&gt; {
    FIELD field1 &lt;field1&gt;
    FIELD field3 &lt;field3&gt;
}
EXPRESSION exp &lt;file.it1 UNION file.it2&gt;
                        </pre>
                    </aside>
                </section>
                <section>
                    <h2>Union over fields</h2>
                    <p>
                        Unions are also capable of handle the union of fields without taking the entire iterators. Therefore, as with the basic expression, it offers more
                        flexibility and granularity when needed. In the example below, field2 and field3 are merged.
                    </p>
                    <aside class="example" title="Union over fields example">
                            <pre>
ITERATOR it1 &lt;xpath: /path/to/entity&gt; {
    FIELD field1 &lt;@attribute1&gt;
    FIELD field2 &lt;field2&gt;
}
ITERATOR it2 &lt;jsonpath: $.path.to.entity&gt; {
    FIELD field1 &lt;field1&gt;
    FIELD field3 &lt;field3&gt;
}
EXPRESSION exp &lt;file.it1.field2 UNION file.it2.field3&gt;
                        </pre>
                    </aside>
                </section>
            </section>
            <section>
                <h2>Join</h2>
                <p>
                    Joins allow to merge the results of two iterators based in a common field. Therefore, if the field values are equal the two iterators results will be merged into a single one. 
                    If the field to be merged exists in both iterators it will generate a list of all the combined results, if a field does not exist in one of the iterators it will only include the results
                    from either the left or the right part containing them.
                </p>
                <aside class="example" title="Join example">
                    <pre>
ITERATOR it1 &lt;xpath: /path/to/entity&gt; {
FIELD field1 &lt;@attribute1&gt;
FIELD field2 &lt;field2&gt;
FIELD field3 &lt;field3&gt;
}
ITERATOR it2 &lt;jsonpath: $.path.to.entity&gt; {
FIELD field1 &lt;field1&gt;
FIELD field3 &lt;field3&gt;
}
EXPRESSION exp &lt;file1.it1 JOIN file2.it2 ON file1.it1.field1 = file2.it2.field1&gt;
                </pre>
            </aside>
            </section>
            <section>
                <h2>Substitution</h2>
                <p>
                    Substitutions permit to extract identifiers information from another file when a common attribute is present. So, for example, if in file A there is an id and a name but
                    in file B there is only a name, it is possible to substitute the result name for the corresponding id when there is a coincidence of names.
                </p>
                <section>
                    <h2>Substitution over iterators</h2>
                    <p>
                        A substitution can be used over iterators when this operation is wanted to be applied over all fields of the iterator. In this case, the operation
                        will work as with fields but taking into account the equality on field naming.
                    </p>
                    <aside class="example" title="Substitution over iterators example">
                            <pre>
ITERATOR it1 &lt;xpath: /path/to/entity&gt; {
    FIELD field1 &lt;@attribute1&gt;
    FIELD field2 &lt;field2&gt;
}
ITERATOR it2 &lt;jsonpath: $.path.to.entity&gt; {
    FIELD field1 &lt;field1&gt;
    FIELD field3 &lt;field3&gt;
}
ITERATOR it3 &lt;jsonpath: $.path.to.entity&gt; {
    FIELD field1 &lt;field1&gt;
    FIELD field4 &lt;field3&gt;
}
EXPRESSION exp &lt;file.it1 UNION file.it2 SUBSTITUTING file.it3&gt;
                        </pre>
                    </aside>
                </section>
                <section>
                    <h2>Substitution over fields</h2>
                    <p>
                        Substitutions can be applied over fields like other expression operators. In this case we can define the results as A, B and C. Consequently, the syntax is
                        A UNION B SUBSTITUTING C where the results of B are replaced for the results of A when C is equal to B. In the example, this is done for substituting the names
                        of B for the ids of A when this is possible. 
                    </p>
                    <aside class="example" title="Substitution over fields example">
                            <pre>
ITERATOR it1 &lt;xpath: /path/to/entity&gt; {
    FIELD id &lt;@id&gt;
    FIELD name &lt;name&gt;
}
ITERATOR it2 &lt;jsonpath: $.path.to.entity&gt; {
    FIELD name &lt;name&gt;
}
EXPRESSION exp &lt;file.it1.id UNION file.it2.name SUBSTITUTING file.it1.name&gt;
                        </pre>
                    </aside>
                </section>
            </section>
            <section>
                <h2>String operation</h2>
                <p>
                    String operation allows to concatenate the results as a string. Thus, permitting to create transformation of the results based on a string concatenation.
                </p>
                <section>
                    <h2>String operation over iterators</h2>
                    <p>
                        String operations can be used with iterators to combine the fields with the same name through a string concatenation. As with other expressions for
                        iterators, the requirement is the equality of the field name. In the example below, field1 of it1 is concatenated with field1 of it2 using a dash to
                        join them. However, field2 and field3 are not concatenated as they do not have the same name.
                    </p>
                    <aside class="example" title="String operation over iterators example">
                        <pre>
ITERATOR it1 &lt;xpath: /path/to/entity&gt; {
    FIELD field1 &lt;@attribute1&gt;
    FIELD field2 &lt;field2&gt;
}
ITERATOR it2 &lt;jsonpath: $.path.to.entity&gt; {
    FIELD field1 &lt;field1&gt;
    FIELD field3 &lt;field3&gt;
}
EXPRESSION exp &lt;file.it1 + "-" + file.it2&gt;
                        </pre>
                    </aside>
                </section>
                <section>
                    <h2>String operation over fields</h2>
                    <p>
                        String operations can be used also with fields as the other expressions visited in this specification. In this case, only the selected fields will be
                        concatenated. This allows to have more flexibility in this kind of transformations that could not be so usual. In the example, field2 and field3 are
                        concatenated using a dash.
                    </p>
                    <aside class="example" title="String operation over fields example">
                        <pre>
ITERATOR it1 &lt;xpath: /path/to/entity&gt; {
    FIELD field1 &lt;@attribute1&gt;
    FIELD field2 &lt;field2&gt;
}
ITERATOR it2 &lt;jsonpath: $.path.to.entity&gt; {
    FIELD field1 &lt;field1&gt;
    FIELD field3 &lt;field3&gt;
}
EXPRESSION exp &lt;file.it1.field2 + "-" + file.it2.field3&gt;
                        </pre>
                    </aside>
                </section>
            </section>
            <section>
                <h2>Matcher</h2>
                <p>
                    Matchers can be used to replace a result for another one. They are designed to change some of the results to a string that can match with some existing
                    URI in the LOD cloud. Therefore, that is why they are called matchers. In this example, a matcher is defined for the region of Asturias where all the
                    possible occurrences in different languages are matched to Asturias as it appears in the URI http://dbpedia.org/resource/Asturias. In the shapes
                    section an example of use will be showed.
                </p>
                <aside class="example" title="Matcher example">
                    <pre>
MATCHER ast &lt;Principality of Asturias, Principado de Asturias, Principáu d'Asturies, Asturies AS Asturias&gt;
                    </pre>
                </aside>
                <section>
                    <h3>Multiple entry Matcher</h3>
                    <p>As a way to avoid defining multiple matchers for different terms it is possible to group them in a single matcher using the "&" operator. Therefore, using the previous example including another entry will look like:</p>
                    <aside class="example" title="Matcher example">
                        <pre>
    MATCHER regions &lt;Principality of Asturias, Principado de Asturias, Principáu d'Asturies, Asturies AS Asturias &
                    Spain, España, Espagne AS Spain&gt;
                        </pre>
                    </aside>
                </section>
            </section>
            <section>
                <h2>Autoincrement ids</h2>
                <p>When there are no natural ids present in the content it can be useful to build your own ones, like autoincremental ids on databases. Therefore in ShExML AUTOINCREMENT keyword allows to define an autoincremental id to be used as subjects in triples. It is defined as the concatenetion of a beginning string (optional), a range definition (mandatory) and an ending string (optional). Range definition is specified as beginning integer (mandatory), an ending range integer (using to keyword and optional, default to infinite) and a step incremental string (using by keyword and optional, default to 1). Therefore, in the following example we define an id which will generate ids: my0Id, my2Id, my4Id, my6Id, my8Id, my10Id.</p>
                <aside class="example" title="Autoincrement id example">
                    <pre>
AUTOINCREMENT myId &lt;"my" + 0 to 10 by 2 + "Id"&gt;
                    </pre>
                </aside>
            </section>
            <section>
                <h2>Functions</h2>
                <p>Functions allow to extend the functionality of ShExML in order to be able to clean, normalise and transform the obtained values before
                    using them in the triples generation. For this purpouse ShExML allows to invoke functions residing in an external Scala class. Then, 
                    the class can be loaded using the FUNCTIONS directive, assigning a variable name for later use and defining the URL where the file resides, in the same
                    manner that we define data sources.
                </p>
                <aside class="example" title="External functions example">
                    <pre>
class Helper {

    def allCapitals(input: String): String = {
        input.toUpperCase
    }
    
    def addOne(number: Int): Int = {
        number + 1
    }
}
                    </pre>
                </aside>
                <aside class="example" title="Example on defining a source of functions">
                    <pre>
FUNCTIONS helper &lt;scala: https://raw.githubusercontent.com/herminiogg/ShExML/enhancement-%23121/src/test/resources/functions.scala&gt;
                    </pre>
                </aside>
            </section>
        </section>
    </section>
    <section>
        <h2>Generators</h2>
        <section>
            <h2>Shapes</h2>
            <p>
                Shapes are the way to define the form of the output data. Shape concept is taken from ShEx and in this specification only basic notions of shapes are
                explained—those notions needed for the understanding of ShExML—so we encourage people who want a further reading to go to ShEx specification [[SHEX]].
            </p>
            <section>
                <h3>Shapes in ShExML</h2>
                <p>
                    Shapes in ShExML are similar to those in ShEx but with some modifications. As showed in the example, a shape is conformed by: the shape name which
                    can take a prefix to define its namespace; the expression for generating the subjects of the triple which is enclosed between square brackets and
                    preceded by the prefix name; and a set of predicate and object tuples. Each of these tuples contain: a predicate in the form of prefix plus 
                    terminal (like in Turtle) and the object which is an expression enclosed between square brackets and with an optional prefix. In the absence
                    of the optional prefix a literal will be generated and an URI if the prefix is present.
                </p>
                <aside class="example" title="Shape example">
                    <pre>
    ITERATOR film_xml &lt;xpath: //film&gt; {
        FIELD id &lt;@id&gt;
        FIELD name &lt;name&gt;
        FIELD year &lt;year&gt;
        FIELD country &lt;country&gt;
        FIELD directors &lt;directors/director&gt;
    }
    ITERATOR film_json &lt;jsonpath: $.films[*]&gt; {
        FIELD id &lt;id&gt;
        FIELD name &lt;name&gt;
        FIELD year &lt;year&gt;
        FIELD country &lt;country&gt;
        FIELD directors &lt;director&gt;
    }
    EXPRESSION films &lt;films_xml_file.film_xml UNION films_json_file.film_json&gt;

    :Films :[films.id] {
        :name [films.name] ;
        :year :[films.year] ;
        :country [films.country] ;
        :director [films.directors] ;
    }
                    </pre>
                </aside>
                <p>
                    In the example above, which is extracted from the first example of this specification, we are defining two iterators that then are merged
                    using the union expression. Then, we define a shape called ':Films' whose subjects are extracted from the union films taking the id attribute.
                    The id attribute is the union of the id fields of both iterators as we have explained earlier. Then 4 tuples of predicate and object are
                    defined. These tuples will generate the different triples as they constitute the basic subject predicate object structure of the RDF triples.
                    Notice that when a ':' is used before an expression, like in films.year, a URI will be generated taking into account the prefix given.
                    In the example below, the same transformation is done but using field expressions instead of iterator expressions.
                </p>
                <aside class="example" title="Shape example">
                    <pre>
    ITERATOR film_xml &lt;xpath: //film&gt; {
        FIELD id &lt;@id&gt;
        FIELD name &lt;name&gt;
        FIELD year &lt;year&gt;
        FIELD country &lt;country&gt;
        FIELD directors &lt;directors/director&gt;
    }
    ITERATOR film_json &lt;jsonpath: $.films[*]&gt; {
        FIELD id &lt;id&gt;
        FIELD name &lt;name&gt;
        FIELD year &lt;year&gt;
        FIELD country &lt;country&gt;
        FIELD directors &lt;director&gt;
    }
    EXPRESSION films_ids &lt;films_xml_file.film_xml.id UNION films_json_file.film_json.id&gt;
    EXPRESSION films_names &lt;films_xml_file.film_xml.name UNION films_json_file.film_json.name&gt;
    EXPRESSION films_years &lt;films_xml_file.film_xml.year UNION films_json_file.film_json.year&gt;
    EXPRESSION films_countries &lt;films_xml_file.film_xml.country UNION films_json_file.film_json.country&gt;
    EXPRESSION films_directors &lt;films_xml_file.film_xml.directors UNION films_json_file.film_json.directors&gt;

    :Films :[films_ids] {
        :name [films_names] ;
        :year :[films_years] ;
        :country [films_countries] ;
        :director [films_directors] ;
    }
                    </pre>
                </aside>
            </section>
            <section>
                <h2>Linking shapes</h2>
                <p>
                    There are occasions when a type has some nested subtypes. In ShEx, it is possible linking shapes to say that an object has to
                    comply with a certain shape. In ShExML, this will trigger the generation of the new entity and they will be linked in RDF using
                    the subject of the nested entity. In the example below an :Actor shape is linked to :Films shape.
                </p>
                <aside class="example" title="Shape example">
                    <pre>
    :Films :[films.id] {
        :name [films.name] ;
        :year :[films.year] ;
        :country [films.country] ;
        :director [films.directors] ;
        :cast @:Actor ;
    }

    :Actor :[films.actors.id] {
        :name [films.actors.name] ;
    }
                    </pre>
                </aside>
            </section>
            <section>
                <h2>Matcher</h2>
                <p>
                    As previously described, a matcher can be used to substitute a result for another string in order to match with some existing URI in
                    the LOD cloud. Firstly, it is declared in the declarations part and then it is used inside the shape in the expression that we want
                    to replace its results. In the example below, Spain mention in Spanish, French, German and Portuguese are converted to the English
                    version to match with the URI http://dbpedia.org/resource/Spain.
                </p>
                <aside class="example" title="Matcher example">
                        <pre>
    MATCHER spain &lt;España, Espagne, Spanien, Espanha AS Spain&gt;

    :Films :[films.id] {
        :name [films.name] ;
        :year :[films.year] ;
        :country dbr:[films.country MATCHING spain] ;
        :director [films.directors] ;
    }
                        </pre>
                    </aside>
            </section>
            <section>
                <h2>Data types (static version)</h2>
                <p>
                    Object generation clauses can be tagged with an XMLSchema data type if a literal is generated (without prefix).
                    Therefore, to output an speficif type, it should be declared after object generation clause (see the example below). 
                </p>
                <aside class="example" title="Static data type declaration">
                    <pre>
    :Films :[films.id] {
        :name [films.name] xsd:string ;
    }
                    </pre>
                </aside>
            </section>
            <section>
                <h2>Data types (dynamic version)</h2>
                <p>
                    It is also possible to retrieve data types values from input sources. For doing so, a generation clause should 
                    be indicated next to the object generation clause (using prefix depending on the input value).
                </p>
                <aside class="example" title="Static data type declaration">
                    <pre>
    :Films :[films.id] {
        :name [films.name] xsd:[films.datatype] ;
        :year [films.name] [films.yearDatatype] ;
    }
                    </pre>
                </aside>
            </section>
            <section>
                <h2>Lang tags (static version)</h2>
                <p>
                    Object generation clauses can be tagged with a lang tag (conformant to BCP 47 [[BCP47]]) indicating the language of the output string.
                    Therefore, to output an speficif lang tag, it should be declared after object generation clause (see the example below). 
                </p>
                <aside class="example" title="Static lang tag declaration">
                    <pre>
    :Films :[films.id] {
        :name [films.name] @en ;
    }
                    </pre>
                </aside>
            </section>
            <section>
                <h2>Lang tags (dynamic version)</h2>
                <p>
                    It is also possible to retrieve lang tag values from input sources. For doing so, a generation clause should 
                    be indicated next to the object generation clause.
                </p>
                <aside class="example" title="Static lang tag declaration">
                    <pre>
    :Films :[films.id] {
        :name [films.name] @[films.lang] ;
    }
                    </pre>
                </aside>
            </section>
            <section>
                <h2>Invoking functions</h2>
                <p>
                    To invoke a function from a previosly declared Scala class the function call should be declared in the generation expression 
                    and the value extraction expressions should be passed as arguments of this call. The syntax follows the same convetions used in
                    object oriented languages like Java and Scala (see the example below).
                </p>
                <aside class="example" title="Static lang tag declaration">
                    <pre>
    :Films :[films.id] {
        :name [helper.allCapitals(films.name)] ;
        :year [helper.addOne(films.year)] ;
    }
                    </pre>
                </aside>
                <section>
                    <h3>Built-in functions</h2>
                    <p>These functions as their name indicates are integrated in the engine and can be called without the need to define them beforehand. 
                        Their intention is to cover functionality not reachable (or too complicated) through the query languages nor by the external functions. 
                        As an example, getting the iteration index of a certain item within an iteration context could result in very complicated external functions which makes
                        it a perfect candidate for integration within the engine default functionality. For the moment only the index function is available, but it is expected to 
                        include more functions under this mechanism in the future.
                    </p>
                    <aside class="example" title="Builtin functions example">
                        <pre>
    :Films :[films.id] {
        :nameIterationIndex [films.name.index()] ; # returns the index of the current name item in the iteration context, i.e., 0, 1, 2, ...
    }
                        </pre>
                    </aside>
                </section>
            </section>
            <section>
                <h2>Conditional statement generation</h2>
                <p>
                    It is possible to generate a statement or not based on a condition. These conditions can be expressed as value extraction expressions or function calls, having in both
                    cases to return a boolean value (true or false). These conditions can be expressed either in subject expressions (conditioning the generation of all the triples containing the
                    concerned subject) or a object expression (conditioning the generation of the triple containing the concerning object). The example below shows how a function can be used in the subject 
                    and in the object expressions.
                </p>
                <aside class="example" title="Static lang tag declaration">
                    <pre>
    :Films :[films.id IF helper.isBefore2010(films.year)] {
        :name [films.name] ;
        :year [films.year] ;
        :countryOfOrigin [films.country IF helper.outsideUSA(films.country)] ;
    }
                    </pre>
                </aside>
            </section>
        </section>
        <section>
            <h2>Graphs</h2>
            <p>Graphs is the mechanism to generate named graphs in ShExML and it follows <a href="https://www.w3.org/2001/sw/wiki/ShEx/Graph_Named_Graphs">the proposed syntax for ShEx</a>. Thus, it is possible to include various shapes inside which generated triples will be under the indicated named graph. Shapes out of any graph definition will be bounded to the default graph as described on the RDF Datasets specification [[RDFDatasets]]. In the example below all triples generated with the :Films shape will be under the :MyFilms graph.</p>
            <aside class="example" title="Graph example">
                <pre>
:MyFilms [[
    :Films :[films.id] {
        :name [films.name] ;
        :year :[films.year] ;
        :country [films.country] ;
        :director [films.directors] ;
    }
]]
                </pre>
            </aside>
        </section>
    </section>
    <section>
        <h2>Other instructions</h2>
        <section>
            <h2>Import</h2>
            <p>
                It is possible to import part of a ShExML script from external files, for that the IMPORT keyword can be used as shown in the example below and at any point in the code. 
                The imports are executed before the script is processed, so if the results of combining the main ShExML script with the external parts does not provide a compliant ShExML script
                the processor will detect it and return the consequent errors.
            </p>
            <aside class="example" title="Import example">
                <pre>
                    PREFIX : &lt;http://example.com/&gt;
                    SOURCE films_xml_file &lt;https://rawgit.com/herminiogg/ShExML/master/src/test/resources/films.xml&gt;
                    SOURCE films_json_file &lt;https://rawgit.com/herminiogg/ShExML/master/src/test/resources/films.json&gt;
                    IMPORT &lt;iterators.shexml&gt;
                    EXPRESSION films &lt;films_xml_file.film_xml UNION films_json_file.film_json&gt;
                    
                    IMPORT &lt;filmShape.shexml&gt;
                </pre>
            </aside>
            <aside class="example" title="Iterators extract for the import as iterators.shexml">
                <pre>
                    ITERATOR film_xml &lt;xpath: //film&gt; {
                        FIELD id &lt;@id&gt;
                        FIELD name &lt;name&gt;
                        FIELD year &lt;year&gt;
                        FIELD country &lt;country&gt;
                        FIELD directors &lt;directors/director&gt;
                    }
                    ITERATOR film_json &lt;jsonpath: $.films[*]&gt; {
                        FIELD id &lt;id&gt;
                        FIELD name &lt;name&gt;
                        FIELD year &lt;year&gt;
                        FIELD country &lt;country&gt;
                        FIELD directors &lt;director&gt;
                    }
                </pre>
            </aside>
            <aside class="example" title="Shapes extract for the import as filmShape.shexml">
                <pre>                
                    :Films :[films.id] {
                        :name [films.name] ;
                        :year [films.year] ;
                        :country [films.country] ;
                        :director [films.directors] ;
                    }
                </pre>
            </aside>
  </body>
</html>